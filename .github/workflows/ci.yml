name: Multi-Step Workflow

on:
  workflow_dispatch:
    inputs:
      ref_name:
        description: "The ref name to use"
        required: true
        default: "main"
      committer_name:
        description: "The committer name to use"
        required: true
        default: "Uniscore Dev"
  push:
    tags:
      - v*
env:
  LC_ALL: en_US.UTF-8
  LANG: en_US.UTF-8
  REF_NAME: ${{ github.event.inputs.ref_name }}
  COMMITTER_NAME: ${{ github.event.inputs.committer_name }}
  P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
  GITLAB_TOKEN: ${{ secrets.GITLAB_TOKEN }}
  MAIN_REPO: ${{ secrets.MAIN_REPO }}
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_GROUP_ID: ${{ vars.TELEGRAM_GROUP_ID }}
  TELEGRAM_TOPIC_ID: ${{ vars.TELEGRAM_TOPIC_ID }}
  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
jobs:
  init:
    runs-on: macos-14
    outputs:
      matrix: ${{ steps.set-matrix.outputs.value }}
      message-information: ${{ steps.get-message-information.outputs.value }}
      env: ${{ steps.set-env.outputs.value }}
    steps:
      - name: Clone GitLab repository
        run: |
          git clone https://oauth2:$GITLAB_TOKEN@gitlab.com/unity1185445/uniscore-mobile.git
          cd uniscore-mobile
          git checkout $REF_NAME

      - name: Set matrix
        id: set-matrix
        run: |
          MATRIX="[{\"format\":\"IPA\",\"name\":\"macos-14\",\"platform\":\"IOS\"},{\"format\":\"APK\",\"name\":\"ubuntu-22.04\",\"platform\":\"ANDROID\"}]"
          if [[ "$REF_NAME" =~ "prod" ]]; then
            MATRIX="[{\"format\":\"IPA\",\"name\":\"macos-14\",\"platform\":\"IOS\"},{\"format\":\"APK\",\"name\":\"ubuntu-22.04\",\"platform\":\"ANDROID\"},{\"format\":\"AAB\",\"name\":\"ubuntu-22.04\",\"platform\":\"ANDROID\"}]"
          fi
          echo "value=$MATRIX" >> $GITHUB_OUTPUT

      - name: Set env
        id: set-env
        run: |
          ENV='dev'
          if [[ "$REF_NAME" =~ "prod" ]]; then
            ENV='prod'
          elif [[ "$REF_NAME" =~ "stag" ]]; then
            ENV='stag'
          elif [[ "$REF_NAME" =~ "beta" ]]; then
            ENV='beta'
          fi
          echo "value=$ENV" >> $GITHUB_OUTPUT

      - name: Generate message
        working-directory: uniscore-mobile
        id: get-message-information
        run: |
          source .github/scripts/utils.sh
          echo "value=$(get_message_information)" >> "$GITHUB_OUTPUT"
        timeout-minutes: 1
      - name: Log value
        run: |
          echo "tag-source: $REF_NAME"
          echo "matrix: ${{ steps.set-matrix.outputs.value }}"
          echo "env: ${{ steps.set-env.outputs.value }}"
      - name: Send telegram message
        env:
          MESSAGE: "üé¨ <b>B·∫Øt ƒë·∫ßu build:</b> ${{ steps.get-message-information.outputs.value }}\n- Thanh ni√™n ·∫•n build üë®‚Äçüíª: ${{ env.COMMITTER_NAME || 'Unknown' }}"
        run: |
          # Build JSON payload using jq for safety
          # Note: We use callback_data instead of url for 'one-click' cancellation
          jq -n --arg chat_id "${TELEGRAM_GROUP_ID}" \
                --arg thread_id "${TELEGRAM_TOPIC_ID}" \
                --arg text "$(echo -e "$MESSAGE")" \
                --arg button_text "‚ùå H·ªßy workflow nha bro" \
                --arg callback_data "cancel_run:${{ github.run_id }}" \
                '{
                  chat_id: $chat_id,
                  message_thread_id: $thread_id,
                  text: $text,
                  parse_mode: "HTML",
                  disable_web_page_preview: true,
                  reply_markup: {
                    inline_keyboard: [[
                      {
                        text: $button_text,
                        callback_data: $callback_data
                      }
                    ]]
                  }
                }' > payload.json

          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -H "Content-Type: application/json" \
            -d @payload.json

  prepare:
    name: Prepare ${{ matrix.format }}
    runs-on: ${{ matrix.name }}
    needs: [init]
    strategy:
      fail-fast: true
      matrix:
        include: ${{ fromJson(needs.init.outputs.matrix) }}
    steps:
      - name: Capture Job Start Time
        run: echo "JOB_START_TIME=$(date +%s)" >> $GITHUB_ENV

      - name: Clone the GitLab repository
        run: |
          git clone https://oauth2:$GITLAB_TOKEN@gitlab.com/unity1185445/uniscore-mobile.git
          cd uniscore-mobile
          git checkout $REF_NAME

      - name: Setup Node v20
        uses: actions/setup-node@v4
        with:
          node-version: "22.21.1"
      - name: Cache node_modules
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: uniscore-mobile/node_modules
          key: ${{ matrix.platform }}-cache-node-modules-${{ hashFiles('uniscore-mobile/package.json') }}
          lookup-only: true
      - name: Run yarn install
        # uses: borales/actions-yarn@v5
        if: steps.cache-node-modules.outputs.cache-hit != 'true'
        run: |
          cd uniscore-mobile
          yarn install --network-concurrency 1

      - name: Run tests
        run: echo "Testing..."

      - name: Analyze Failure with AI
        if: ${{ failure() }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # 1. Get the failed job logs (limit to last 200 lines)
          LOGS=$(gh run view ${{ github.run_id }} --log-failed | tail -n 200)
          
          # 2. Build Prompt
          PROMPT="H√£y ph√¢n t√≠ch c√°c log l·ªói GitHub Action sau ƒë√¢y v√† cung c·∫•p m·ªôt b·∫£n t√≥m t·∫Øt ng·∫Øn g·ªçn v·ªÅ nh·ªØng g√¨ ƒë√£ sai v√† c√°ch kh·∫Øc ph·ª•c b·∫±ng ti·∫øng Vi·ªát. Gi·ªØ n·ªôi dung d∆∞·ªõi 200 t·ª´. Tr·∫£ v·ªÅ k·∫øt qu·∫£ d∆∞·ªõi d·∫°ng text thu·∫ßn t√∫y, kh√¥ng d√πng markdown qu√° ph·ª©c t·∫°p.\n\nLog:\n$LOGS"
          
          # 3. Build JSON payload using jq
          jq -n --arg prompt "$PROMPT" '{contents: [{parts: [{text: $prompt}]}]}' > payload.json

          # 4. Send to Gemini for analysis (3-tier fallback)
          ANALYSIS=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload.json | jq -r '.candidates[0].content.parts[0].text // empty')

          if [[ -z "$ANALYSIS" || "$ANALYSIS" == "null" ]]; then
            ANALYSIS=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-lite-latest:generateContent?key=$GEMINI_API_KEY" \
              -H "Content-Type: application/json" \
              -d @payload.json | jq -r '.candidates[0].content.parts[0].text // empty')
          fi

          if [[ -z "$ANALYSIS" || "$ANALYSIS" == "null" ]]; then
            ANALYSIS=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=$GEMINI_API_KEY" \
              -H "Content-Type: application/json" \
              -d @payload.json | jq -r '.candidates[0].content.parts[0].text // "Kh√¥ng th·ªÉ ph√¢n t√≠ch l·ªói l√∫c n√†y."')
          fi
          
          # 5. Save analysis to a file
          echo "$ANALYSIS" > ai_analysis_prepare.txt

      - name: Send telegram message failure
        if: ${{ failure() }}
        uses: UniscoreDev/macos-telegram-action@main
        with:
          type: topic
          message: |
            üí• - Th·∫•t b·∫°i r·ªìi b·∫°n hi·ªÅn ${{ matrix.platform }}: ${{ needs.init.outputs.message-information }}
            
            ü§ñ **Ph√¢n t√≠ch AI:**
            $(cat ai_analysis_prepare.txt 2>/dev/null || echo "Kh√¥ng c√≥ ph√¢n t√≠ch n√†o.")

  deploy:
    name: Deployment ${{ matrix.format }}
    continue-on-error: true
    strategy:
      fail-fast: true
      matrix:
        include: ${{ fromJson(needs.init.outputs.matrix) }}
    runs-on: ${{ matrix.name }}
    needs: [init, prepare]
    timeout-minutes: 60
    env:
      START_TIME: ${{ github.event.repository.updated_at }} # Placeholder, will set actual start time in steps
    steps:
      - name: Free Disk Space (Ubuntu)
        if: matrix.platform == 'ANDROID'
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          tool-cache: false
          android: false
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Set Start Time
        run: echo "JOB_START_TIME=$(date +%s)" >> $GITHUB_ENV

      # Step 3: Clone the GitLab repository manually using git
      - name: Clone GitLab repository
        run: |
          git clone https://oauth2:$GITLAB_TOKEN@gitlab.com/unity1185445/uniscore-mobile.git
          cd uniscore-mobile
          git checkout $REF_NAME

      # # Step 4: Move all files from the cloned GitLab repository to the root directory (./)
      # - name: Move files to root
      #   run: |
      #     mv uniscore-mobile/* ./
      #     mv uniscore-mobile/.[!.]* ./
      #     rm -rf uniscore-mobile
      - name: Setup ruby 3.1.4
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.3.4"
          bundler-cache: true
      - name: Bundle install
        working-directory: uniscore-mobile
        run: bundle install
      - name: Setup Node v20
        uses: actions/setup-node@v4
        with:
          node-version: "22.21.1"

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        if: matrix.platform == 'ANDROID'
        with:
          java-version: "17"
          distribution: "temurin"
          # cache: "gradle"

      - name: Setup Android SDK
        if: matrix.platform == 'ANDROID'
        uses: android-actions/setup-android@v3

      - name: Setup Android NDK
        uses: nttld/setup-ndk@v1
        if: matrix.platform == 'ANDROID'
        with:
          ndk-version: r26c

      - name: Setup cocoapods
        if: matrix.platform == 'IOS'
        uses: maxim-lobanov/setup-cocoapods@v1
        with:
          version: 1.16.2

      - name: Select Xcode
        if: matrix.platform == 'IOS'
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: "16.1.0"
      # - name: remove pod
      #   run: |
      #     rm -rf uniscore-mobile/ios/Pods
      #     rm -rf uniscore-mobile/ios/Podfile.lock
      - name: Cache node_modules
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: uniscore-mobile/node_modules
          key: ${{ matrix.platform }}-cache-node-modules-${{ hashFiles('uniscore-mobile/package.json') }}
      # - name: Cache Pods
      #   if: matrix.platform == 'IOS'
      #   id: cache-pods
      #   uses: actions/cache@v4
      #   with:
      #     path: |
      #       uniscore-mobile/ios/Pods
      #       uniscore-mobile/ios/Podfile.lock
      #     key: cache-pods-${{ hashFiles('uniscore-mobile/package.json') }}

      - name: Pod install
        if: ${{ (matrix.platform == 'IOS') }}
        working-directory: uniscore-mobile/ios
        run: pod install
      - name: Setup Node v18
        uses: actions/setup-node@v4
        with:
          node-version: "22.21.1"
      # - name: Cache Xcode DerivedData
      #   if: matrix.platform == 'IOS'
      #   uses: actions/cache@v4
      #   with:
      #     path: |
      #       ~/Library/Developer/Xcode/DerivedData
      #     key: xcode-deriveddata-${{ needs.init.outputs.env }}-${{ hashFiles('uniscore-mobile/ios/Podfile.lock', 'uniscore-mobile/package.json') }}
      #     restore-keys: |
      #       xcode-deriveddata-${{ needs.init.outputs.env }}-
      # - name: Cache node_modules
      #   id: cache-node-modules
      #   uses: actions/cache@v4
      #   with:
      #     path: uniscore-mobile/node_modules
      #     key: ${{ matrix.platform }}-cache-node-modules-${{ hashFiles('uniscore-mobile/package.json') }}
      #     lookup-only: true
      # - name: Run yarn install
      #   # uses: borales/actions-yarn@v5
      #   run: |
      #     cd uniscore-mobile
      #     yarn install --network-concurrency 1

      # - name: Pod install
      #   if: ${{ (matrix.platform == 'IOS') }}
      #   working-directory: uniscore-mobile/ios
      #   run: pod install

      # - name: Cache Xcode build
      #   uses: irgaly/xcode-cache@v1
      #   if: matrix.platform == 'IOS'
      #   with:
      #     key: xcode-cache-deriveddata-${{ needs.init.outputs.env }}-${{ hashFiles('uniscore-mobile/package.json') }}
      #     restore-keys: xcode-cache-deriveddata-${{ needs.init.outputs.env }}-

      - name: Change version and build number
        working-directory: uniscore-mobile
        run: bash .github/scripts/change_version_and_build_number.sh

      - name: Install certificate and provision
        if: matrix.platform == 'IOS'
        working-directory: uniscore-mobile
        run: bash .github/scripts/install_cert_and_provision.sh

      - name: Link Node (/usr/local/bin/node)
        if: matrix.platform == 'IOS'
        run: ln -s $(command -v node) /usr/local/bin/node
      # Build IPA d·ª±a theo m√¥i tr∆∞·ªùng
      - name: Build IPA Dev Release
        if: ${{matrix.format == 'IPA' && needs.init.outputs.env == 'dev'}}
        working-directory: uniscore-mobile
        run: yarn build:ios-dev-release

      - name: Build IPA Staging Release
        if: ${{matrix.format == 'IPA' && needs.init.outputs.env == 'stag'}}
        working-directory: uniscore-mobile
        run: yarn build:ios-stag-release
      - name: Build IPA Beta Release
        if: ${{matrix.format == 'IPA' && needs.init.outputs.env == 'beta'}}
        working-directory: uniscore-mobile
        run: yarn build:ios-beta-release
      - name: Build IPA Staging Release
        if: ${{matrix.format == 'IPA' && needs.init.outputs.env == 'prod'}}
        working-directory: uniscore-mobile
        run: yarn build:ios-prod-release
      # Build APK d·ª±a theo m√¥i tr∆∞·ªùng
      - name: Build APK
        if: ${{matrix.format == 'APK' && needs.init.outputs.env == 'dev'}}
        working-directory: uniscore-mobile
        run: yarn build:dev:apk

      - name: Build APK Staging
        if: ${{matrix.format == 'APK' && needs.init.outputs.env == 'stag'}}
        working-directory: uniscore-mobile
        run: yarn build:stag:apk
      - name: Build APK Beta
        if: ${{matrix.format == 'APK' && needs.init.outputs.env == 'beta'}}
        working-directory: uniscore-mobile
        run: yarn build:beta:apk
      - name: Build APK Production
        if: ${{matrix.format == 'APK' && needs.init.outputs.env == 'prod'}}
        working-directory: uniscore-mobile
        run: yarn build:prod:apk
      #  Push to testflight
      - name: Push to testflight dev
        if: ${{ matrix.format == 'IPA' && needs.init.outputs.env == 'dev' }}
        working-directory: uniscore-mobile
        run: bundle exec fastlane ios testflight

      - name: Push to testflight staging
        if: ${{ matrix.format == 'IPA' && needs.init.outputs.env == 'stag' }}
        working-directory: uniscore-mobile
        run: bundle exec fastlane ios testflight_stag

      - name: Push to testflight beta
        if: ${{ matrix.format == 'IPA' && needs.init.outputs.env == 'beta' }}
        working-directory: uniscore-mobile
        run: bundle exec fastlane ios testflight_alpha

      - name: Push to testflight production
        if: ${{ matrix.format == 'IPA' && needs.init.outputs.env == 'prod' }}
        working-directory: uniscore-mobile
        run: bundle exec fastlane ios testflight_prod
      # Deploy apk
      - name: Deploy apk
        if: ${{ matrix.format == 'APK' && needs.init.outputs.env == 'dev' }}
        working-directory: uniscore-mobile
        run: bundle exec fastlane android dev

      - name: Deploy apk
        if: ${{ matrix.format == 'APK' && needs.init.outputs.env == 'stag' }}
        working-directory: uniscore-mobile
        run: bundle exec fastlane android staging

      - name: Deploy apk
        if: ${{ matrix.format == 'APK' && needs.init.outputs.env == 'beta' }}
        working-directory: uniscore-mobile
        run: bundle exec fastlane android beta

      - name: Generate Release Notes & Stats
        if: ${{ success() }}
        working-directory: uniscore-mobile
        run: |
          # 1. Get Commits (last 10 commits or since last tag)
          COMMITS=$(git log -n 10 --pretty=format:"- %s")
          
          # 2. AI Generate Release Notes (3-tier fallback)
          PROMPT="D·ª±a tr√™n danh s√°ch commit sau, h√£y vi·∫øt m·ªôt b·∫£n t√≥m t·∫Øt 'C√≥ g√¨ m·ªõi' ng·∫Øn g·ªçn, vui v·∫ª b·∫±ng ti·∫øng Vi·ªát (t·ªëi ƒëa 5 bullet points, m·ªói d√≤ng t·ªëi ƒëa 60 k√Ω t·ª±). Kh√¥ng d√πng markdown ph·ª©c t·∫°p.\n\nCommits:\n$COMMITS"
          jq -n --arg prompt "$PROMPT" '{contents: [{parts: [{text: $prompt}]}]}' > payload_notes.json

          RELEASE_NOTES=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_notes.json | jq -r '.candidates[0].content.parts[0].text // empty')

          if [[ -z "$RELEASE_NOTES" || "$RELEASE_NOTES" == "null" ]]; then
            RELEASE_NOTES=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-lite-latest:generateContent?key=$GEMINI_API_KEY" \
              -H "Content-Type: application/json" \
              -d @payload_notes.json | jq -r '.candidates[0].content.parts[0].text // empty')
          fi

          if [[ -z "$RELEASE_NOTES" || "$RELEASE_NOTES" == "null" ]]; then
            RELEASE_NOTES=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=$GEMINI_API_KEY" \
              -H "Content-Type: application/json" \
              -d @payload_notes.json | jq -r '.candidates[0].content.parts[0].text // "C·∫≠p nh·∫≠t h·ªá th·ªëng v√† s·ª≠a l·ªói v·∫∑t."')
          fi
          # Truncate release notes to avoid Telegram limit (max 600 chars)
          echo "${RELEASE_NOTES:0:600}" > ../release_notes.txt

          # 3. Calculate Build Stats
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - JOB_START_TIME))
          MINUTES=$((DURATION / 60))
          SECONDS=$((DURATION % 60))
          echo "${MINUTES}m ${SECONDS}s" > ../build_duration.txt

          # 4. Get File Size
          if [[ "${{ matrix.platform }}" == "ANDROID" ]]; then
            FILE_PATH=$(find android/app/build/outputs -name "*.apk" -o -name "*.aab" | head -n 1)
          else
            FILE_PATH=$(find ios/build -name "*.ipa" | head -n 1)
          fi
          
          if [[ -f "$FILE_PATH" ]]; then
            du -sh "$FILE_PATH" | cut -f1 > ../build_size.txt
          else
            echo "N/A" > ../build_size.txt
          fi

          # 5. AI Build Mood
          MOOD_PROMPT="D·ª±a tr√™n c√°c commit sau, h√£y ƒë·∫∑t m·ªôt c√°i t√™n 'h√†i h∆∞·ªõc, l·∫ßy l·ªôi' b·∫±ng ti·∫øng Vi·ªát cho b·∫£n build n√†y k√®m theo emoji (v√≠ d·ª•: 'B·∫£n build ch·∫°y b·∫±ng ni·ªÅm tin ü§°' ho·∫∑c 'Si√™u nh√¢n s·ª≠a bug ü¶∏‚Äç‚ôÇÔ∏è'). Ch·ªâ tr·∫£ v·ªÅ c√°i t√™n, kh√¥ng th√™m g√¨ kh√°c.\n\nCommits:\n$COMMITS"
          jq -n --arg prompt "$MOOD_PROMPT" '{contents: [{parts: [{text: $prompt}]}]}' > payload_mood.json
          
          BUILD_MOOD=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_mood.json | jq -r '.candidates[0].content.parts[0].text // "B·∫£n build ·∫©n danh üé≠"')
          echo "$BUILD_MOOD" > ../build_mood.txt

      - name: Send telegram message for iOS
        if: ${{ matrix.platform == 'IOS' && success() }}
        run: |
          MESSAGE="‚úÖ <b>Build th√†nh c√¥ng ${{ matrix.format }} r·ªìi h√†ng ƒë√£ c√≥ tr√™n TestFlight:</b>\n${{ needs.init.outputs.message-information }}"
          jq -n --arg chat_id "${TELEGRAM_GROUP_ID}" \
                --arg thread_id "${TELEGRAM_TOPIC_ID}" \
                --arg text "$(echo -e "$MESSAGE")" \
                '{chat_id: $chat_id, message_thread_id: $thread_id, text: $text, parse_mode: "HTML", disable_web_page_preview: true}' > payload_ios.json
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" -H "Content-Type: application/json" -d @payload_ios.json

      - name: Send telegram message for Android
        if: ${{ matrix.platform == 'ANDROID' && success() }}
        run: |
          MESSAGE="‚úÖ <b>Build th√†nh c√¥ng ${{ matrix.format }} r·ªìi h√†ng ƒë√£ c√≥ tr√™n App Distribution:</b>\n${{ needs.init.outputs.message-information }}"
          jq -n --arg chat_id "${TELEGRAM_GROUP_ID}" \
                --arg thread_id "${TELEGRAM_TOPIC_ID}" \
                --arg text "$(echo -e "$MESSAGE")" \
                '{chat_id: $chat_id, message_thread_id: $thread_id, text: $text, parse_mode: "HTML", disable_web_page_preview: true}' > payload_android.json
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" -H "Content-Type: application/json" -d @payload_android.json

      # Combined "What's New" notification is sent by 'notify' job after all platforms complete

      - name: Analyze Failure with AI
        if: ${{ failure() }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # 1. Try multiple methods to get error logs
          echo "üîç Attempting to capture failure logs..."
          
          # Method 1: Get failed step logs from current run
          LOGS=""
          LOGS=$(gh run view ${{ github.run_id }} --log-failed 2>/dev/null | tail -n 150 || echo "")
          
          # Method 2: If empty, try to get recent logs from the run
          if [[ -z "$LOGS" || ${#LOGS} -lt 50 ]]; then
            LOGS=$(gh run view ${{ github.run_id }} --log 2>/dev/null | grep -i -A 5 -B 2 "error\|failed\|exception\|fatal" | tail -n 150 || echo "")
          fi
          
          # Method 3: Fallback - provide context about the failing job
          if [[ -z "$LOGS" || ${#LOGS} -lt 50 ]]; then
            LOGS="Build ${{ matrix.format }} for ${{ matrix.platform }} failed. Run ID: ${{ github.run_id }}. Please check the workflow run for details."
          fi
          
          # Debug: Show what we captured
          echo "üìã Captured ${#LOGS} characters of logs"
          
          # 2. Build Prompt with specific instructions
          PROMPT="B·∫°n l√† AI chuy√™n ph√¢n t√≠ch l·ªói CI/CD. Ph√¢n t√≠ch log l·ªói sau v√† tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát:\n\n1. **L·ªói g√¨?** (1 d√≤ng ng·∫Øn g·ªçn)\n2. **Nguy√™n nh√¢n:** (1-2 d√≤ng)\n3. **C√°ch s·ª≠a:** (1-2 d√≤ng c·ª• th·ªÉ)\n\nGi·ªØ t·ªïng c·ªông d∆∞·ªõi 150 t·ª´. Kh√¥ng d√πng markdown ph·ª©c t·∫°p.\n\nLog:\n$LOGS"
          
          # 3. Build JSON payload using jq
          jq -n --arg prompt "$PROMPT" '{contents: [{parts: [{text: $prompt}]}]}' > payload_fail.json

          # 4. Send to Gemini for analysis (3-tier fallback)
          ANALYSIS=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_fail.json | jq -r '.candidates[0].content.parts[0].text // empty')

          if [[ -z "$ANALYSIS" || "$ANALYSIS" == "null" ]]; then
            ANALYSIS=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-lite-latest:generateContent?key=$GEMINI_API_KEY" \
              -H "Content-Type: application/json" \
              -d @payload_fail.json | jq -r '.candidates[0].content.parts[0].text // empty')
          fi

          if [[ -z "$ANALYSIS" || "$ANALYSIS" == "null" ]]; then
            ANALYSIS="‚ö†Ô∏è Kh√¥ng th·ªÉ ph√¢n t√≠ch t·ª± ƒë·ªông. Vui l√≤ng xem log tr·ª±c ti·∫øp."
          fi
          
          # Truncate analysis to fit Telegram limit
          ANALYSIS="${ANALYSIS:0:500}"

          # 5. Generate funny failure mood
          FAIL_MOOD_PROMPT="ƒê·∫∑t m·ªôt c√°i t√™n h√†i h∆∞·ªõc, l·∫ßy l·ªôi b·∫±ng ti·∫øng Vi·ªát cho m·ªôt build b·ªã l·ªói k√®m emoji bu·ªìn (v√≠ d·ª•: 'B·∫£n build ra ƒëi kh√¥ng l·ªùi t·ª´ bi·ªát üíÄ' ho·∫∑c 'Bug 1 - Dev 0 üò≠'). Ch·ªâ tr·∫£ v·ªÅ c√°i t√™n, t·ªëi ƒëa 40 k√Ω t·ª±."
          jq -n --arg prompt "$FAIL_MOOD_PROMPT" '{contents: [{parts: [{text: $prompt}]}]}' > payload_fail_mood.json
          
          FAIL_MOOD=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_fail_mood.json | jq -r '.candidates[0].content.parts[0].text // "Build ƒë√£ hy sinh üíÄ"')
          FAIL_MOOD="${FAIL_MOOD:0:50}"

          # 6. Build complete failure message
          VERSION_INFO="${{ needs.init.outputs.message-information }}"
          RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          {
            echo "TELEGRAM_FAIL_MESSAGE<<EOF"
            echo "üí• <b>${FAIL_MOOD}</b>"
            echo ""
            echo "‚ùå <b>Build th·∫•t b·∫°i:</b> ${{ matrix.format }} (${{ matrix.platform }})"
            echo "${VERSION_INFO}"
            echo ""
            echo "ü§ñ <b>Ph√¢n t√≠ch AI:</b>"
            echo "${ANALYSIS}"
            echo ""
            echo "üîó Xem chi ti·∫øt: ${RUN_URL}"
            echo "EOF"
          } >> $GITHUB_ENV

      - name: Send telegram message failure
        if: ${{ failure() }}
        run: |
          # Build JSON payload using jq for safety
          jq -n --arg chat_id "${TELEGRAM_GROUP_ID}" \
                --arg thread_id "${TELEGRAM_TOPIC_ID}" \
                --arg text "$(echo -e "${{ env.TELEGRAM_FAIL_MESSAGE }}")" \
                '{
                  chat_id: $chat_id,
                  message_thread_id: $thread_id,
                  text: $text,
                  parse_mode: "HTML",
                  disable_web_page_preview: true
                }' > payload_fail.json

          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -H "Content-Type: application/json" \
            -d @payload_fail.json

  notify:
    name: Send Success Notification
    runs-on: ubuntu-latest
    needs: [init, deploy]
    if: ${{ success() }}
    steps:
      - name: Clone GitLab repository
        run: |
          git clone https://oauth2:$GITLAB_TOKEN@gitlab.com/unity1185445/uniscore-mobile.git
          cd uniscore-mobile
          git checkout $REF_NAME

      - name: Generate Release Notes & Build Message
        id: generate-message
        working-directory: uniscore-mobile
        run: |
          # 1. Get Commits (last 10 commits)
          COMMITS=$(git log -n 10 --pretty=format:"- %s")
          
          # 2. AI Generate Release Notes (3-tier fallback) - max 1500 chars
          PROMPT="D·ª±a tr√™n danh s√°ch commit sau, h√£y vi·∫øt m·ªôt b·∫£n t√≥m t·∫Øt 'C√≥ g√¨ m·ªõi' ng·∫Øn g·ªçn, vui v·∫ª b·∫±ng ti·∫øng Vi·ªát. Y√™u c·∫ßu: b·∫Øt ƒë·∫ßu m·ªói d√≤ng b·∫±ng d·∫•u g·∫°ch ƒë·∫ßu d√≤ng (-), t·ªëi ƒëa 10 d√≤ng, m·ªói d√≤ng t·ªëi ƒëa 100 k√Ω t·ª±. Kh√¥ng d√πng markdown ph·ª©c t·∫°p, kh√¥ng ƒë√°nh s·ªë.\n\nCommits:\n$COMMITS"
          jq -n --arg prompt "$PROMPT" '{contents: [{parts: [{text: $prompt}]}]}' > payload_notes.json

          RELEASE_NOTES=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_notes.json | jq -r '.candidates[0].content.parts[0].text // empty')

          if [[ -z "$RELEASE_NOTES" || "$RELEASE_NOTES" == "null" ]]; then
            RELEASE_NOTES=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-lite-latest:generateContent?key=$GEMINI_API_KEY" \
              -H "Content-Type: application/json" \
              -d @payload_notes.json | jq -r '.candidates[0].content.parts[0].text // empty')
          fi

          if [[ -z "$RELEASE_NOTES" || "$RELEASE_NOTES" == "null" ]]; then
            RELEASE_NOTES=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=$GEMINI_API_KEY" \
              -H "Content-Type: application/json" \
              -d @payload_notes.json | jq -r '.candidates[0].content.parts[0].text // "- C·∫≠p nh·∫≠t h·ªá th·ªëng v√† s·ª≠a l·ªói."')
          fi
          
          # Truncate and clean release notes
          RELEASE_NOTES=$(echo "$RELEASE_NOTES" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          RELEASE_NOTES="${RELEASE_NOTES:0:1500}"

          # 3. AI Build Mood (max 60 chars)
          MOOD_PROMPT="D·ª±a tr√™n c√°c commit sau, h√£y ƒë·∫∑t m·ªôt c√°i t√™n 'h√†i h∆∞·ªõc, l·∫ßy l·ªôi' b·∫±ng ti·∫øng Vi·ªát cho b·∫£n build n√†y k√®m theo emoji (v√≠ d·ª•: 'B·∫£n build ch·∫°y b·∫±ng ni·ªÅm tin ü§°'). Ch·ªâ tr·∫£ v·ªÅ c√°i t√™n, t·ªëi ƒëa 50 k√Ω t·ª±.\n\nCommits:\n$COMMITS"
          jq -n --arg prompt "$MOOD_PROMPT" '{contents: [{parts: [{text: $prompt}]}]}' > payload_mood.json
          
          BUILD_MOOD=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_mood.json | jq -r '.candidates[0].content.parts[0].text // "B·∫£n build ·∫©n danh üé≠"')
          BUILD_MOOD="${BUILD_MOOD:0:60}"

          # 4. Build complete message (ensure all static parts are always present)
          VERSION_INFO="${{ needs.init.outputs.message-information }}"
          ENV="${{ needs.init.outputs.env }}"
          RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          # Get environment emoji
          case "$ENV" in
            dev) ENV_EMOJI="üõ†Ô∏è Development" ;;
            stag) ENV_EMOJI="üß™ Staging" ;;
            beta) ENV_EMOJI="üéØ Beta" ;;
            prod) ENV_EMOJI="üöÄ Production" ;;
            *) ENV_EMOJI="üì¶ $ENV" ;;
          esac
          
          # Get current timestamp in Vietnam timezone
          BUILD_TIME=$(TZ='Asia/Ho_Chi_Minh' date '+%d/%m/%Y %H:%M')
          
          # Construct the full message with proper escaping for multiline
          {
            echo "TELEGRAM_MESSAGE<<EOF"
            echo "üéâ <b>${BUILD_MOOD}</b>"
            echo ""
            echo "‚úÖ <b>ƒê√É S·∫¥N S√ÄNG TR√äN C·∫¢ iOS V√Ä ANDROID!</b>"
            echo ""
            echo "üì± <b>iOS:</b> TestFlight"
            echo "ü§ñ <b>Android:</b> App Distribution"
            echo ""
            echo "${VERSION_INFO}"
            echo "üåç <b>M√¥i tr∆∞·ªùng:</b> ${ENV_EMOJI}"
            echo "üïê <b>Th·ªùi gian:</b> ${BUILD_TIME}"
            echo ""
            echo "üìù <b>C√≥ g√¨ m·ªõi:</b>"
            echo "${RELEASE_NOTES}"
            echo "EOF"
          } >> $GITHUB_ENV

      - name: Send combined Telegram notification
        run: |
          # Build JSON payload using jq for safety
          jq -n --arg chat_id "${TELEGRAM_GROUP_ID}" \
                --arg thread_id "${TELEGRAM_TOPIC_ID}" \
                --arg text "$(echo -e "${{ env.TELEGRAM_MESSAGE }}")" \
                '{
                  chat_id: $chat_id,
                  message_thread_id: $thread_id,
                  text: $text,
                  parse_mode: "HTML",
                  disable_web_page_preview: true
                }' > payload_success.json

          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -H "Content-Type: application/json" \
            -d @payload_success.json

  cleanup:
    name: Cleanup & Cancel Notification
    runs-on: ubuntu-latest
    if: ${{ always() && cancelled() }}
    steps:
      - name: Send cancellation message
        run: |
          MESSAGE="üö´ <b>Workflow ƒë√£ b·ªã h·ªßy th√†nh c√¥ng!</b>"
          
          # Build JSON payload using jq for safety
          jq -n --arg text "$(echo -e "$MESSAGE")" \
                --arg chat_id "${TELEGRAM_GROUP_ID}" \
                --arg thread_id "${TELEGRAM_TOPIC_ID}" \
                '{chat_id: $chat_id, message_thread_id: $thread_id, text: $text, parse_mode: "HTML", disable_web_page_preview: true}' > payload.json

          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -H "Content-Type: application/json" \
            -d @payload.json

